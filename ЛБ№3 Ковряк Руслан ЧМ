import numpy as np
import scipy.misc as nd

def f(x):
    return 6*x**4 - 4*x**3 - x**2 - x - 10  # Змінено рівняння на 6x^4 - 4x^3 - x^2 - x - 10

eps=0.0001

def find_segments():
    search_range = np.arange(-100, 100, 1)

    previous_x = None
    segments = []

    for x in search_range:
        x = round(x, 4)
        current_x = f(x)
        if previous_x != None and previous_x * current_x < 0:
            segments.append((a, x))
        a = x
        previous_x = current_x
    return segments

def newton(a, b, eps, f):
    df2 = nd.derivative(f, b, n=2)  # Отримання значення другої похідної в точці b
    if f(b) * df2 > 0:
        xi = b
    else:
        xi = a
    df = nd.derivative(f, xi, n=1)  # Отримання значення першої похідної в точці xi
    xi_1 = xi - f(xi) / df
    while abs(xi_1 - xi) > eps:  # Перевірка точності
        xi = xi_1
        xi_1 = xi - f(xi) / df
    print('Метод Ньютона, x = ', xi_1.round(4))

def hybrid(a, b, eps, f):
    if nd.derivative(f, a, n=1) * nd.derivative(f, a, n=2) > 0:
        a0 = a
        b0 = b
    else:
        a0 = b
        b0 = a
    ai = a0
    bi = b0
    while abs(ai - bi) > eps:
        ai_1 = ai - f(ai) * (bi - ai) / (f(bi) - f(ai))
        bi_1 = bi - f(bi) / nd.derivative(f, bi, n=1)
        ai = ai_1
        bi = bi_1
    x = (ai_1 + bi_1) / 2
    print('Комбінований метод, x = ', x.round(4))

if __name__ == "__main__":
    newton(-2, -1, eps, f)  # Метод Ньютона на іншому відрізку
    hybrid(-2, -1, eps, f)  # Комбінований метод на іншому відрізку
